"""
Clip Assembly Models - PR 303: Clip Assembly & DB/Redis Integration
"""

from enum import Enum
from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field
from datetime import datetime

from .replicate_client import ClipMetadata, GenerationStatus, VideoResolution, VideoFormat


class ClipStorageStatus(str, Enum):
    """Status of clip storage and processing"""
    PENDING = "pending"      # Clip generation requested but not yet stored
    GENERATING = "generating"  # Clip is being generated by Replicate
    COMPLETED = "completed"   # Clip successfully generated and stored
    FAILED = "failed"        # Clip generation failed
    RETRYING = "retrying"    # Clip is being retried


class DatabaseClipMetadata(BaseModel):
    """
    Extended clip metadata for database storage

    Builds on Replicate ClipMetadata with additional database fields
    for ordering, progress tracking, and relational data.
    """

    # Core clip information (from Replicate)
    clip_id: str = Field(..., description="Unique ID for this clip")
    generation_id: str = Field(..., description="ID of the generation job this clip belongs to")
    scene_id: str = Field(..., description="ID of the scene this clip represents")

    # Ordering and sequencing
    sequence_order: int = Field(..., ge=0, description="Order of this clip in the final video (0-based)")
    start_time_seconds: float = Field(..., ge=0.0, description="Start time in final video (seconds)")
    end_time_seconds: float = Field(..., ge=0.0, description="End time in final video (seconds)")

    # Storage and processing status
    storage_status: ClipStorageStatus = Field(default=ClipStorageStatus.PENDING, description="Current storage/processing status")
    storage_path: Optional[str] = Field(None, description="Local storage path if downloaded")
    last_updated: datetime = Field(default_factory=datetime.utcnow, description="Last status update")

    # Video details (copied from Replicate metadata)
    video_url: Optional[str] = Field(None, description="URL to the generated video file")
    duration_seconds: float = Field(..., ge=0.0, description="Actual duration of the generated video")
    resolution: VideoResolution = Field(default=VideoResolution.RES_720P, description="Video resolution")
    format: VideoFormat = Field(default=VideoFormat.MP4, description="Video format")

    # Generation metadata
    model_used: str = Field(default="google/veo-3.1-fast", description="Replicate model used for generation")
    prompt_used: str = Field(..., description="The prompt that was sent to the model")
    negative_prompt_used: Optional[str] = Field(None, description="Negative prompt used")

    # Quality and performance metrics
    generation_time_seconds: Optional[float] = Field(None, ge=0.0, description="Time taken to generate the video")
    model_version: Optional[str] = Field(None, description="Specific model version used")
    quality_score: Optional[float] = Field(None, ge=0.0, le=1.0, description="Model-reported quality score")

    # Timestamps
    created_at: datetime = Field(default_factory=datetime.utcnow, description="When clip record was created")
    generation_started_at: Optional[datetime] = Field(None, description="When generation started")
    generation_completed_at: Optional[datetime] = Field(None, description="When generation completed")

    # Error information (if failed)
    error_message: Optional[str] = Field(None, description="Error message if generation/storage failed")
    error_code: Optional[str] = Field(None, description="Error code if generation/storage failed")
    retry_count: int = Field(default=0, description="Number of retry attempts")

    # Additional metadata
    file_size_bytes: Optional[int] = Field(None, description="Size of the video file in bytes")
    thumbnail_url: Optional[str] = Field(None, description="URL to video thumbnail")
    tags: List[str] = Field(default_factory=list, description="Tags for organization and filtering")

    def is_successful(self) -> bool:
        """Check if the clip generation and storage was successful"""
        return (self.storage_status == ClipStorageStatus.COMPLETED and
                self.error_message is None and
                self.video_url is not None)

    def get_summary(self) -> str:
        """Get a human-readable summary of the clip"""
        status = "✅ Completed" if self.is_successful() else f"❌ {self.storage_status.value}"
        if self.error_message:
            status += f": {self.error_message[:50]}..."
        return f"Clip {self.clip_id} (#{self.sequence_order}): {self.duration_seconds:.1f}s, {self.resolution}, {status}"

    def to_replicate_metadata(self) -> ClipMetadata:
        """Convert to Replicate ClipMetadata format"""
        return ClipMetadata(
            clip_id=self.clip_id,
            generation_id=self.generation_id,
            scene_id=self.scene_id,
            video_url=self.video_url or "",
            duration_seconds=self.duration_seconds,
            resolution=self.resolution,
            format=self.format,
            model_used=self.model_used,
            prompt_used=self.prompt_used,
            negative_prompt_used=self.negative_prompt_used,
            generation_time_seconds=self.generation_time_seconds or 0.0,
            model_version=self.model_version,
            quality_score=self.quality_score,
            created_at=self.created_at,
            completed_at=self.generation_completed_at,
            error_message=self.error_message,
            error_code=self.error_code
        )

    @classmethod
    def from_replicate_metadata(
        cls,
        replicate_metadata: ClipMetadata,
        sequence_order: int,
        start_time: float,
        end_time: float
    ) -> 'DatabaseClipMetadata':
        """Create DatabaseClipMetadata from Replicate ClipMetadata"""
        return cls(
            clip_id=replicate_metadata.clip_id,
            generation_id=replicate_metadata.generation_id,
            scene_id=replicate_metadata.scene_id,
            sequence_order=sequence_order,
            start_time_seconds=start_time,
            end_time_seconds=end_time,
            video_url=replicate_metadata.video_url,
            duration_seconds=replicate_metadata.duration_seconds,
            resolution=replicate_metadata.resolution,
            format=replicate_metadata.format,
            model_used=replicate_metadata.model_used,
            prompt_used=replicate_metadata.prompt_used,
            negative_prompt_used=replicate_metadata.negative_prompt_used,
            generation_time_seconds=replicate_metadata.generation_time_seconds,
            model_version=replicate_metadata.model_version,
            quality_score=replicate_metadata.quality_score,
            generation_completed_at=replicate_metadata.completed_at,
            error_message=replicate_metadata.error_message,
            error_code=replicate_metadata.error_code,
            storage_status=ClipStorageStatus.COMPLETED if replicate_metadata.is_successful() else ClipStorageStatus.FAILED
        )


class GenerationProgress(BaseModel):
    """
    Progress tracking for video generation jobs

    Tracks overall generation progress and individual clip status.
    """

    generation_id: str = Field(..., description="ID of the generation job")

    # Overall progress
    status: GenerationStatus = Field(default=GenerationStatus.QUEUED, description="Overall generation status")
    progress_percentage: float = Field(default=0.0, ge=0.0, le=100.0, description="Overall completion percentage")
    current_step: str = Field(default="initializing", description="Current processing step")

    # Clip tracking
    total_clips: int = Field(default=0, description="Total number of clips to generate")
    completed_clips: int = Field(default=0, description="Number of clips completed")
    failed_clips: int = Field(default=0, description="Number of clips that failed")
    current_clip_index: Optional[int] = Field(None, description="Index of currently processing clip")

    # Timing
    started_at: Optional[datetime] = Field(None, description="When generation started")
    estimated_completion_at: Optional[datetime] = Field(None, description="Estimated completion time")
    last_updated: datetime = Field(default_factory=datetime.utcnow, description="Last progress update")

    # Performance metrics
    total_generation_time_seconds: float = Field(default=0.0, description="Total time spent generating")
    average_clip_time_seconds: Optional[float] = Field(None, description="Average time per clip")

    def update_progress(self) -> None:
        """Update progress percentage based on clip completion"""
        if self.total_clips > 0:
            self.progress_percentage = (self.completed_clips / self.total_clips) * 100.0
        else:
            self.progress_percentage = 0.0

    def get_summary(self) -> str:
        """Get a human-readable progress summary"""
        return f"Generation {self.generation_id}: {self.progress_percentage:.1f}% complete ({self.completed_clips}/{self.total_clips} clips)"


class ClipAssemblyRequest(BaseModel):
    """
    Request to assemble clips for a generation job

    Contains all clips and metadata needed to store them in database/Redis.
    """

    generation_id: str = Field(..., description="ID of the generation job")

    # Clip data
    clips: List[DatabaseClipMetadata] = Field(..., description="List of clips to store")

    # Progress information
    progress: GenerationProgress = Field(..., description="Current generation progress")

    # Additional context
    total_expected_clips: int = Field(..., description="Total number of clips expected for this generation")
    force_update: bool = Field(default=False, description="Force update even if clips exist")


class ClipAssemblyResponse(BaseModel):
    """
    Response from clip assembly operation
    """

    generation_id: str
    clips_stored: int = Field(..., description="Number of clips successfully stored")
    progress_updated: bool = Field(default=True, description="Whether progress was updated")
    success: bool = Field(default=True, description="Overall success of the operation")

    # Details
    stored_clip_ids: List[str] = Field(default_factory=list, description="IDs of clips that were stored")
    errors: List[str] = Field(default_factory=list, description="Any errors that occurred")

    # Timestamps
    completed_at: datetime = Field(default_factory=datetime.utcnow, description="When assembly completed")


class ClipRetrievalRequest(BaseModel):
    """
    Request to retrieve clips for a generation job
    """

    generation_id: str = Field(..., description="ID of the generation job")
    include_failed: bool = Field(default=False, description="Include failed clips in results")
    order_by_sequence: bool = Field(default=True, description="Order by sequence rather than creation time")


class ClipRetrievalResponse(BaseModel):
    """
    Response containing retrieved clips
    """

    generation_id: str
    clips: List[DatabaseClipMetadata] = Field(..., description="Retrieved clips")
    progress: Optional[GenerationProgress] = Field(None, description="Current progress if available")

    # Metadata
    total_clips: int = Field(..., description="Total number of clips found")
    successful_clips: int = Field(..., description="Number of successful clips")
    failed_clips: int = Field(..., description="Number of failed clips")


class ClipOrderingRule(BaseModel):
    """
    Rule for ordering clips in final assembly
    """

    rule_type: str = Field(..., description="Type of ordering rule (sequence, temporal, custom)")
    priority: int = Field(default=1, description="Priority of this rule (higher = more important)")
    description: str = Field(..., description="Human-readable description of the rule")

    # Rule parameters
    parameters: Dict[str, Any] = Field(default_factory=dict, description="Rule-specific parameters")
